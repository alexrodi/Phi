/*
  ==============================================================================

    PlugHandler.h
    Created: 1 Feb 2021 8:58:27pm
    Author:  Alexandre Rodrigues

  ==============================================================================
*/

#pragma once

struct PlugID
{
    PlugID(std::pair<uint32, uint32> moduleplugID) :
    ownID( (uint64(moduleplugID.first) << 32) | uint64(moduleplugID.second) )
    {}

    PlugID(uint64 moduleplugID) : ownID(moduleplugID)
    {}
    
    PlugID(int64 moduleplugID) : ownID(moduleplugID)
    {}
    
    PlugID(String moduleplugIDString) : ownID(moduleplugIDString.toUTF8().getIntValue64())
    {}
    
    PlugID() : ownID(0)
    {}
    
    PlugID operator= (uint64 other) { ownID = other; return *this; }
    
    uint32 moduleID() const noexcept
    {
        return uint32(ownID >> 32);
    }
    
    uint32 plugID() const noexcept
    {
        return uint32(ownID & 0x00000FFFFF);
    }
    
    String toString() const noexcept
    {
        return String(ownID);
    }
    
    operator uint64() const noexcept {return ownID;}
    operator int64() const noexcept {return ownID;}
    
    bool operator== (const PlugID& other) const noexcept
    {
        return other.ownID == ownID;
    }
    
private:
    uint64 ownID;
};

/// This Class may exist in one of two modes
enum PlugMode { Inlet, Outlet };

/// An Event generated by a Plug
struct PlugEvent {
    virtual ~PlugEvent() { ptr.release(); };
    
    PlugEvent(): ptr(this){}
    PlugEvent(const PlugEvent& event): ptr(this){}
    
    /// Tries to cast itself as an Event-derived class, returns nullptr if it fails
    /// Use to match events like:
    /**
     @code
     if (auto object = event.as<MouseDown>()) {
         // Object is a MouseDown
         // Do something with object...
     } else if (auto object = event.as<MouseUp>()) {
         // Object is a MouseUp
         // Do something with object...
     } else if (auto object = event.as<Drag>()) {
         // Object is a Drag
         // Do something with object...
     }
     @endcode
     */
    template<class T>
    const T* as() const {
        return dynamic_cast<T*>(ptr.get());
    }
private:
    std::unique_ptr<PlugEvent> ptr;
};

struct PlugMouseDown : public PlugEvent {
    PlugMouseDown(PlugMode mode, PlugID plugID): mode(mode), plugID(plugID){}
    PlugMode mode; PlugID plugID;
};
struct PlugMouseUp : public PlugEvent {
    PlugMouseUp(bool keepConnectedToSource):
    keepConnectedToSource(keepConnectedToSource)
    {}
    bool keepConnectedToSource;
};
struct PlugDrag : public PlugEvent {};
struct PlugConnect : public PlugEvent {
    PlugConnect(PlugID source, PlugID destination):
    source(source),
    destination(destination)
    {}
    PlugID source, destination;
};

class PlugListener {
public:
    virtual ~PlugListener() = default;
    virtual void onPlugEvent(const PlugEvent& event) = 0;
};

class PlugEventEmitter {
public:
    // These methods are used by objects that want to subscribe and unsubscribe from changes that occur in this plug
    void addListener(PlugListener *l) {listeners.add(l);}
    void removeListener(PlugListener *l) {listeners.remove(l);}
    
    template<class T> void emitEvent(const T event) {
         // call the onPlugEvent method of every listener that has subscribed to be notified
         // pass in the value so that listeners can use it however they please
          listeners.call([event](PlugListener &l){ l.onPlugEvent(event); });
    }
    
private:
    ListenerList<PlugListener> listeners;
};

class PlugManager: public PlugListener {
    
};
